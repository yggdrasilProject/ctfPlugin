package ru.linachan.ctf.common;

import com.google.common.base.Joiner;
import org.json.simple.JSONArray;
import org.json.simple.parser.JSONParser;
import ru.linachan.yggdrasil.YggdrasilCore;
import ru.linachan.yggdrasil.common.Queue;
import ru.linachan.yggdrasil.scheduler.YggdrasilRunnable;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ExploitExecutor implements YggdrasilRunnable {

    private String[] exploitCommand;
    private File workingDirectory;

    private boolean running;
    private boolean started;

    private ExecutorService threadPool = Executors.newWorkStealingPool();

    private List<String> executionLog = new CopyOnWriteArrayList<>();
    private List<String> executionFlags = new CopyOnWriteArrayList<>();

    public ExploitExecutor(String... command) {
        exploitCommand = command;

        try {
            workingDirectory = Utils.createTempDirectory("exploit");
        } catch (IOException e) {
            logger.error("Unable to create working directory: {}", e.getMessage());
        }
    }

    private ProcessBuilder getProcessBuilder(String... args) {
        ProcessBuilder processBuilder = new ProcessBuilder(args);

        processBuilder.environment().clear();
        processBuilder.environment().put("WORKSPACE", workingDirectory.getAbsolutePath());

        processBuilder.directory(workingDirectory);

        return processBuilder;
    }

    @Override
    @SuppressWarnings("unchecked")
    public void run() {
        ProcessBuilder processBuilder = getProcessBuilder(exploitCommand);

        running = true;
        started = true;

        try {
            if (processBuilder != null) {
                executionLog.clear();
                executionFlags.clear();

                Process process = processBuilder.start();

                InputStream outputStream = process.getInputStream();
                InputStream errorStream = process.getErrorStream();

                IOThread output = new IOThread(this, outputStream, "output");
                IOThread errors = new IOThread(this, errorStream, "error");

                threadPool.submit(output);
                threadPool.submit(errors);

                process.waitFor();

                int exitCode = process.exitValue();

                if (exitCode == 0) {
                    for (String flag: executionFlags) {
                        ((Queue<String>)YggdrasilCore.INSTANCE.getQueue("ctfFlags")).push(String.format("%s:%d", flag, 1));
                    }
                }

                logger.error("Execution log:\n{}", Joiner.on('\n').join(executionLog));

                process.destroy();
                running = false;
            } else {
                running = false;
            }
        } catch (InterruptedException | IOException e) {
            e.printStackTrace();
        }
    }

    public boolean isRunning() {
        return running || !started;
    }

    public synchronized void putLine(String streamName, String line) throws IOException {
        switch (streamName) {
            case "error":
                executionLog.add(line);
                break;
            case "output":
                executionFlags.add(line);
                break;
        }

    }

    @Override
    public void onCancel() {
        running = started = false;

        threadPool.shutdown();
    }

    public String getCommand() {
        return Joiner.on(' ').join(exploitCommand);
    }
}
